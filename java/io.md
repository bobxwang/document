#### 传输方式上

> 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同对应的字节也不同，如 utf-8编码是3个字节而中文编码是2个字节)
>
> 字节流用来处理二进制文件(图片/MP3)，字符流用来处理文本文件(可看做是特殊的二进制使用了某种编码导至人可以阅读)

- 字节流，计算机看的
- 字符流，人看的

#### 字节转字符 Input/OutputStreamReader/Writer

> 编码就是把字符转换成字节，而解码就是字节重新组合成字符

####数据操作上

- file /  pipe / buffer 

#### 模型

###### Unix 五种I/O模型

- 阻塞式

  > 应用进程被阻塞直到数据复制到应用进程缓冲区，在阻塞的过程中，其它程序还可以执行，并不会消耗CPU时间

- 非阻塞式

  > 应用进程执行系统调用后，内核会返回一个码，应用进程可以继续执行，但需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询。需要CPU参与

- I/O多路复用(select/poll/epoll)，又称事件驱动

  > 使用 select/poll 等待数据并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞。它可以让单个进程具有处理多个I/O事件的能力，又被称为Event Driven I/O
  >
  > epoll 的描述事件有两种触发模式
  >
  > - LT(level trigger) 当epoll_wait检测到描述符事件时将此事件通知进程，而进程可以不立即处理此事件，下次调用epoll_wait会再次通知进程。是默认的模式，同时支持 Blocking 跟 No-Blocking
  > - ET(edge trigger)，跟 LT 不同的是，通知后进程必须马上处理事件，下次调用 epoll_wait 时不会再得到事件到达的通知，减少了被重复触发的次数，效率比LT高，但只支持 No-Blocking
  >
  > select / poll / epoll 区别
  >
  > - select 的timeout参数精度是 1ns，而 poll / epoll 为 1ms，因此 select 更加适用于实时要求高的场景，同时其可移植性更好，几乎被所有主流平台支持
  > - poll没有最大描述符数量的限制，如果平台支持且实时性不高，应使用poll而不是select
  > - epoll只运行在Linux平台，并有非常大量的描述符需同时轮询而且最好是长连接 

- 信号驱动

  > 应用进程使用sigaction系统调用，内核立即返回。应用进程可继续执行，也就是说等待数据阶段应用进程是非阻塞的，内核在数据到达时就应用进程发送 SIGIO 信号，应用进程在收到之后在信号处理程序中调用 receform 将数据从内核复制到应用进程中
  >
  > <font color=blue>相比于非阻塞式的轮询，信号驱动的CPU利用率更高</font>

- 异步I/O(AIO)

  > 进行read系统调用会立即返回，应用继续执行不会被阻塞，内核会在所有操作完成后向应用进程发送信号，<font color=red>跟信号驱动不同的是，异步IO的信号是通知应用进程I/O完成，而信号驱动I/O是通知应用进程可以开始I/O</font>

###### 同步/异步 IO

> 阻塞式/非阻塞式/复用/信号驱动都是同步IO，只有AIO是异步IO
>
> 这两个概念是<font color=red>操作系统级别</font>，主要描述的是OS在收到请求操作后，如果IO资源没准备好，前者是不响应直到资源准备好，而后者是返回一个标记(好让程序跟自己知道以后数据往哪通知)，当资源准备好后再用事件机制返回给程序

- 同步IO，应用进程在调用 recvfrom 操作时会被阻塞
- 异步IO，不会阻塞

###### 阻塞 IO/ 非阻塞 IO

> 这两个概念是<font color=red>程序级别</font>，主要描述的是程序请求操作系统IO后，如果资源没有准备好，那么程序该如何处理呢？前者是等待，而后者是继续执行（并且使用线程一直轮询，直到有IO资源）

##### Blocking IO

> 应用程序向OS请求网络IO操作，此时应用程序会一直等待，另一方面，操作系统收到请求后也会等待直到网络上有数据传到监听端口，操作系统在收到数据后，会把数据发给应用程序，最后应用程序收到数据，解除等待状态。
>
> BIO问题关键不在于是否使用了多线程(包括线程池)，而在于 accept/read 的操作点都是被阻塞的

##### NIO

> NIO 是以块的方式处理数据，而I/O是以流的方式处理数据，两者最重要的区别是数据打包跟传输的方式。
>
> 实现多路复用的 Reactor 模型

- Channel 是对原 I/O 包中流的模拟，通过它读取跟写入数据，同时是双向。
- Buffer 发送给通道的所有数据必须先放到缓冲区中，同样的从通道中读取数据也是先读到缓冲区
  - capacity  最大容量
  - position  当前已经读写的字节数
  - limit 还可以读写的字节数
- Selector 

##### Zero Copy

###### Java NIO

- MappedByteBuffer

  > 基于内存映射，使用的是堆外虚拟内存，因此不受 -Xmx参数限制，其在处理大文件时性能的确很高，但也存在内存占用，文件关闭等不确定问题

- DirectByteBuffer

  > 此对象位于Java内存模型的堆里，JVM可对其对象做内存分配跟回收管理，继承自 MappedByteBuffer

- FileChannel 

###### Netty

> Netty 中的零拷贝跟上面提到的操作系统层面上的零拷贝不太一样，Netty的零拷贝完全是基于(Java层面)用户态的，它更多的是偏向于数据操作优化这样的概念，具体表现在:
>
> - 通过DefaultFileRegion对java.nio.channedls.FileChannel的 tranferTo 方法进行包装，在文件传输时可将文件缓冲区数据直接发送到目的通道
> - ByteBuf 通过wrap 操作，同时提供 CompositeByteBuf(可将多个ByteBuf合并为一个逻辑上的ByteBuf)

###### RocketMQ

> 选择了 mmap+write 的方式，适用于业务级消息这种小块文件的数据持久化跟传输，<font color=blue>不过其不能很好的采用DMA方式，会比sendfile多消耗CPU，内存安全性控制复杂，需要避免JVM Crash 问题</font>

###### Kafka

> 采用的是 sendfile 这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化跟传输，不过只是数据文件采用了 sendfile，其索引文件采用的也是 mmap+write 方式 





#### 